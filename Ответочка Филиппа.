Общие вопросы:
1) Каждая нить действует на своём процессоре. Или ядре.
Процессор - это одна железка в компьютере. Ядро - это часть этой железки, способная работать независимо от остальных частей.
Параллелить вычисления можно и на процессорах, и на ядрах, например:
	а) 1 комп, 1 проц, 4 ядра. Можно запустить 4 нити.
	б) 4 компа, в каждом по одноядерному процу. Можно связать компы в сеть (пиздатое слово - в кластер) и запустить 4 нити.
	в) 4 компа, в каждом по четырёхядерному процу. Можно связать компы в кластер и запустить 16 нитей.
Можно запускать и больше нитей, но смысл? Они тогда попадут на одно и то же ядро, и ускорения ты не получишь.
Почему? Потому что одна нить - это ПОСЛЕДОВАТЕЛЬНЫЙ алгоритм. Нить - это всё то, что ты писал (или не писал) на первом курсе на семинарах по программированию. А одно ядро может выполнять в один момент времени только ОДИН последовательный алгоритм. Потому что так оно устроено.
И что с того? И то, что если ты попытаешься запустить две нити на одном ядре, ты не оставишь ему другого выбора, кроме как выполнять их по очереди. Сначала 1 миллисекунду первую нить. Потом 1 миллисекунду вторую нить. Потом снова первую. Потом снова вторую. Ну и так далее.
И где ускорение? Ускорение есть, если что-то выполняется параллельно. А у нас нифига не выполняется параллельно: ядро дёргает нити по очереди. Так что нет у нас ускорения. Так что нет смысла пускать несколько нитей на одно ядро.

Подводим итог. Смысл распараллеливания в том, чтобы выполнять вычисления параллельно. Чтобы вычислялось быстрее. Но одно ядро не может выполнять вычисления параллельно. Поэтому варианты:
	а) Запихнуть несколько ядер в один проц.
	б) Связать несколько одноядерных процов в кластер.
	в) Объединить а и б.

P. S.: Частенько последовательный исполнитель называется процессором, а не ядром, из-за этого возникает путаница. Почему так? Потому что раньше все процессоры были одноядерными. Да и вообще люди не придумали ещё процессор на ядра разбить. Теперь последовательный исполнитель - это ЯДРО, а процессоры, имеющие несколько ядер, могут работать параллельно. Но многие по-старинке говорят, что послед. исполнитель - процессор.


2) Да. Для private определённым будет только значение переменной у нити-мастера.
3) Не шарю этой опции, все проги для Рубена были сданы без неё :)
4) Частично ответил в пункте 1. А так-то если нитей...
	а) столько же, сколько и ядер: идеальная ситуация, все заняты своим делом.
	б) меньше, чем ядер: некоторые ядра простаивают.
	в) больше, чем ядер: на некоторые ядра попадут по две нити. См. пункт 1.



sum.c:
Пара советов по коду. Хоть ты и не просил советы, но я их дам. Потому что не уверен, что код будет работать.
1) В код до параллельной секции нужно добавить две штуки:
        omp_set_dynamic(0);
        omp_set_num_threads(num);
Что они делают - читай в мануале. num стоит ввести с клавиатуры вместе с num_of_iter.
И вообще, в начале любой проги следует запиливать эти штуковины. Хотя бы потому, что так сказал Рубен.
2) После 
	#pragma omp parallel for
нужно сказать, какого типа переменные, используемые в цикле, который ты параллелишь (прайват / шэред).

Твои вопросы:
"Лучше ли сделать через опцию reduction? Можно ли оставить parallel for?"
Не знаю такой опции. Сам писал через parallel for, всё работает.

"Как объяснить ситуацию с точки зрения действий, происходящих в ядрах/процессорах?"
Попробуй курнуть травку.




transmission.c:
1) Опять же, типы переменных.
2) Опять же, две штуки.

"Оптимально ли решение? Решение ли для той задачи? Скорее всего, не оптимально, тогда как лучше?"
Не знаю. Да. См. ниже.
Ты удивишься, но я решал практически так же, но добавил немного наворотов. И я не уверен, что эти навороты нужны. Так что это мне следует волноваться по поводу оптимальности моего кода.
Попробуй учесть мои советы 1) и 2) и запустить код. Если заработает, то супер, ты придумал более оптимальное решение, чем я. Если нет, то придётся добавлять навороты.
Более оптимальное, возможно, можно получить через локи, но я не советую тебе сейчас туда лезть, это отнюдь не просто.




example?.c:
Не знаю, что такое single-область.




example2?.c:
Не понял вопроса... Где там какое глобальное имя?
